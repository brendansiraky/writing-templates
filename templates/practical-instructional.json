{
  "id": "practical-instructional",
  "name": "Practical Instructional",
  "one_liner": "Like reading documentation written by someone who respects your time so much they made every sentence do work.",
  "meta": {
    "style_tags": [
      "Action-oriented",
      "Direct",
      "Efficient",
      "Instructional",
      "Clear"
    ],
    "mood": [
      "Purposeful",
      "Confident",
      "Respectful"
    ],
    "energy": "medium",
    "density": "moderate",
    "formality": "medium",
    "warmth": "cool",
    "vocabulary_level": "intermediate",
    "best_for": [
      "Technical documentation",
      "How-to guides",
      "README files",
      "API documentation",
      "Product guides",
      "Tutorials"
    ],
    "avoid_for": [
      "Personal essays",
      "Literary fiction",
      "Brand storytelling",
      "Eulogy or tribute writing",
      "Persuasive opinion pieces"
    ]
  },
  "spec": {
    "vocabulary_and_diction": "Use the shortest common word that is precise. 'Use' not 'utilize,' 'start' not 'initiate,' 'set up' not 'configure' (unless configure is the technical term). Prefer Anglo-Saxon root words for verbs and common nouns: 'run,' 'send,' 'build,' 'check.' Reserve Latinate vocabulary for domain-specific terms where precision demands it — 'authenticate' is fine because 'prove who you are' is ambiguous. Every technical term earns its place: if the reader needs the term to do the task, define it on first use in a parenthetical or appositive ('the payload — the data your request sends to the server'). If the reader doesn't need the term, cut it. Target a 9th-grade reading level for surrounding prose, with technical terms as the only exceptions. Concrete nouns over abstractions: 'the config file' not 'the configuration layer,' 'the response' not 'the output artifact.' Verbs should be imperative or active: 'Add the key to your .env file' not 'The key should be added to the .env file.' Ban these words and phrases: 'leverage,' 'utilize,' 'facilitate,' 'robust,' 'seamless,' 'cutting-edge,' 'best-in-class,' 'it should be noted that,' 'it is important to,' 'in order to' (just say 'to'), 'ensure that' (say 'make sure' or restructure), 'prior to' (say 'before'), 'subsequently' (say 'then'). Jargon policy: use the term your reader already knows from the tool or platform. Match the UI label exactly — if the button says 'Deploy,' write 'click Deploy,' not 'click the deployment button.'",
    "sentence_construction": "Average sentence length: 10-16 words. Procedural sentences (steps) should be 6-12 words. Explanatory sentences can extend to 20 words, never beyond 25. Front-load the verb: start imperative sentences with the action in the first 3 words — 'Add your API key,' not 'In order to authenticate, you'll need to add your API key.' One idea per sentence. If a sentence contains 'and' joining two instructions, split it into two sentences. Prefer simple and compound sentences; use complex sentences (with a subordinate clause) only to state a condition before an action: 'If the build fails, check the error log.' Place the condition clause first, action second — the reader needs to evaluate the condition before acting. Never nest subordinate clauses. Parallelism is mandatory in all lists and steps: match grammatical structure exactly — 'Install the CLI, create a project, and deploy your app' not 'Install the CLI, a project should be created, and then you can deploy.' One-word sentences are permitted for warnings or emphasis, maximum once per section: 'Don't.' or 'Stop.'",
    "rhythm_and_cadence": "Aim for a steady, forward pulse — not musical, not staccato, just momentum. The reader should feel pulled through the text without noticing the prose. Alternate between short instructional sentences (6-10 words) and slightly longer explanatory ones (14-20 words) in a 2:1 ratio. Avoid three consecutive sentences of the same length. End key sentences on strong, stressed monosyllables where possible: 'file,' 'key,' 'test,' 'run.' Avoid trailing prepositional phrases that dilute the ending: 'Save the file' not 'Save the file to the directory on your local machine.' Read every paragraph as if the reader is scanning — the first 3 words of each sentence should be meaningful even if the rest is skipped. No sentence fragments except for the rare emphatic one-worder. The rhythm should feel like good directions from someone who knows the route: confident, unrushed, no wasted turns.",
    "paragraph_architecture": "Target 2-4 sentences per paragraph. The first sentence states what this paragraph helps the reader do or understand. The remaining sentences provide the how. One paragraph, one action or concept — never bundle two tasks in one paragraph. If a paragraph exceeds 4 sentences, split it. Single-sentence paragraphs are permitted for warnings, caveats, or pivots between sections — no more than once per 400 words. End paragraphs on the completion of the action, not on a transition to the next topic. Each paragraph should be independently scannable: a reader skimming only first sentences should get the full procedure.",
    "opening_patterns": {
      "articles": "Open with what the reader will be able to do after reading. First sentence states the outcome: 'This guide walks you through deploying a Node.js app to production in under ten minutes.' Second sentence states the prerequisite or scope: 'You'll need a running Postgres instance and an API key from the dashboard.' Never open with background, history, or motivation. Never open with 'In this article, we will explore...' or 'Have you ever wondered...' The reader already decided to read — tell them what they'll get and what they need.",
      "sections": "Open each section with the task it accomplishes, using an imperative or outcome-oriented sentence: 'Set up your local environment' or 'Connect the database.' If context is needed, deliver it in the second sentence, not the first. Never open a section with a summary of what you're about to explain — just start explaining. If the section is a step in a procedure, the heading is the step, and the first sentence is the first sub-action.",
      "paragraphs": "Lead with the action verb or the key noun. Strong openers: 'Run npm install,' 'The config file controls three settings,' 'Your API key expires after 30 days.' Weak openers: 'It is worth noting that,' 'There are several ways to,' 'As previously mentioned,' 'Interestingly,' 'One important thing to keep in mind is.' If a paragraph starts with a conditional, put the condition in a dependent clause and the action in the main clause: 'If you're using Docker, mount the volume first.'"
    },
    "closing_patterns": "End pieces with the reader's next action, not a summary. The final paragraph should be 1-2 sentences pointing forward: 'You now have a running production deployment. To add a custom domain, see the DNS configuration guide.' Never end with a philosophical reflection, a rhetorical question, or 'Happy coding!' Never restate what the piece covered — the reader just read it. If there is nothing to point to next, end on the last concrete action: 'Run the test suite. If all tests pass, your setup is complete.' The last word of the piece should be a noun or verb, not an adverb or adjective.",
    "transitions_and_connectives": "Use minimal explicit connectives. Let numbered steps and clear section headings carry the sequence. When a connective is needed, prefer plain ones: 'Then,' 'Next,' 'Now,' 'But,' 'If,' 'Once that's done.' Never use: 'Furthermore,' 'Moreover,' 'Additionally,' 'Consequently,' 'Nevertheless,' 'In conclusion,' 'Having established that,' 'As we saw earlier,' 'Let's now turn to,' 'With that in mind.' Temporal connectives ('First,' 'Then,' 'Finally') are acceptable in procedural sequences but should be embedded in the sentence, not set off with a comma as a sentence-opener — 'Then run the migration' not 'Then, run the migration.' The best transition in instructional writing is a heading. If two paragraphs need a transition, consider whether they belong under different headings instead.",
    "pacing_and_information_flow": "Front-load the outcome, then deliver the procedure. Structure pieces as: (1) what you'll build or achieve, (2) prerequisites, (3) steps in order, (4) verification, (5) next steps. Within each step, give the action first, then the explanation: 'Run npm test. This executes the full test suite against your local database.' — not 'The test suite runs against your local database. To execute it, run npm test.' Cognitive load management: never introduce more than one new concept per paragraph. If a step requires a detour to explain a concept, use a short parenthetical or a separate 'Background' subsection — don't bury the explanation inside the procedure. Keep the critical path clean: the reader following the steps should never have to read an explanation to complete the action. Explanations are supplements, not prerequisites.",
    "overall_voice": "Reading this style feels like pair-programming with a senior engineer who has done this setup fifty times. They don't lecture. They don't explain the history of the framework. They say what you need to type, what you should see, and what to do if something goes wrong. There's a human behind the prose — you can tell because the word choices are natural and the occasional aside ('this part is easier than it looks') shows judgment, not just procedure. But the human stays out of the way. The writing is confident without being authoritative — it earns trust by being right, not by claiming expertise. Every sentence moves the reader closer to done.",
    "emotional_register": "Permitted emotions: quiet confidence, practical encouragement, honest acknowledgment of difficulty. Express confidence through directness, not assertion: say 'This takes about five minutes' not 'Don't worry, this is easy!' Acknowledge difficulty briefly and factually: 'The OAuth flow has several moving parts. Take it step by step.' Never use exclamation marks for enthusiasm. Never say 'Congratulations!' or 'Great job!' — the reader's reward is the working thing, not your praise. When something is genuinely tricky, say so: 'This is the hardest part of the setup. Read the error messages carefully.' The emotional baseline is calm competence — a colleague who assumes you're capable and treats you accordingly.",
    "humor_and_personality": "Humor is rare, dry, and never signposted. It appears as an understated observation, roughly once per 800-1000 words: 'The default timeout is 30 seconds, which is generous.' or 'You'll need three environment variables. The naming convention is not obvious.' Never make a joke about the reader's intelligence or experience level. Never use exclamation marks for humor. Never use 'Fun fact:' or 'Pro tip:' as labels — just state the tip. Personality emerges through specificity and judgment calls: choosing to mention the non-obvious gotcha, recommending one approach over another with a brief reason, noting when something is simpler than it appears. The writer has opinions but holds them lightly: 'We recommend Postgres. SQLite works for development but won't scale.' Self-deprecation is forbidden. Puns are forbidden. 'Nerd humor' references to movies or games are forbidden.",
    "rhetorical_devices": "Use sparingly, and only in service of clarity. Analogies: permitted when a technical concept maps cleanly to a familiar one — 'Environment variables work like settings on a thermostat: you set them once and the system reads them as needed.' Maximum one analogy per 600 words. Analogies must be precise: if the mapping breaks down when pushed, cut it. Tricolon: permitted in summaries — 'Install, configure, deploy.' Never as rhetorical flourish. Litotes: occasionally, to acknowledge complexity without dramatizing — 'not trivial,' 'not the most intuitive.' Never use: anaphora (repetition for emphasis), apostrophe (addressing abstract concepts), rhetorical questions, hypophora (asking then answering), metaphors that require unpacking, similes that call attention to themselves. If you catch yourself writing a figure of speech, ask whether a plain statement would be clearer. It almost always is.",
    "use_of_evidence_and_examples": "Every instruction must be verifiable. After a step, tell the reader what they should see: 'Run npm start. You should see Server running on port 3000 in your terminal.' Code examples are mandatory for any operation involving a command, configuration, or API call — never describe code in prose when you can show it. Keep code examples minimal: the shortest snippet that demonstrates the point, with no extraneous lines. When referencing a tool or service, name the version: 'Node.js 18+' not 'a recent version of Node.' When a claim needs support, use a specific number or observable outcome: 'This reduces build time by about 40%' or 'The response includes a status field set to active.' Never reference vague best practices: 'many developers prefer' or 'it's generally recommended.' Either cite the specific recommendation or state the reason directly.",
    "point_of_view_and_person": "Default to second person ('you') for instructions: 'You can find your API key in the dashboard.' Use imperative mood for steps: 'Create a new file called config.yml.' Use first-person plural ('we') sparingly, only when walking through a procedure together: 'We'll start by setting up the database, then move to the API layer.' Never use 'we' as a corporate or editorial 'we' — it should feel like two people at a desk. Never use first-person singular ('I') except in clearly marked asides or opinionated recommendations: 'I'd recommend Postgres over MySQL for this use case.' Use third person for describing system behavior: 'The server validates the token and returns a session ID.' Never address the reader with false intimacy ('friend,' 'folks') or false formality ('the user,' 'one').",
    "punctuation_and_mechanics": "Em-dashes: maximum 1 per 500 words, used to insert a brief clarification — 'the payload — your request body — must be valid JSON.' Never two em-dash pairs in one paragraph. Semicolons: avoid entirely; use two sentences instead. Oxford comma: always. Exclamation marks: never. Period after every imperative sentence, including steps. Colons: use before code examples, single-item illustrations, or inline definitions. Never use a colon to introduce a clause that could stand alone. Parentheses: permitted for brief clarifications (1-8 words), version numbers, and keyboard shortcuts — no more than twice per section. Contractions: use them ('don't,' 'you'll,' 'it's') — uncontracted forms sound robotic. But don't contract 'do not' in warnings: 'Do not delete the production database.' Backticks: use for any inline code, file name, command, variable name, or UI element — `config.yml`, `npm install`, `PORT`. Bold: use sparingly for key terms on first definition or for warning labels (**Warning:** or **Note:**). Italic: only for introducing a term or for emphasis that genuinely changes meaning, maximum once per 500 words.",
    "formatting_and_structure": "Use descriptive, action-oriented headings in sentence case: 'Set up your database' not 'Database Setup' or 'Setting Up the Database.' Headings should be scannable as a table of contents — a reader seeing only headings should understand the full procedure. Use H2 for major sections, H3 for subsections within a section. Never skip heading levels. Numbered lists for sequential steps. Bulleted lists for non-sequential items (prerequisites, options, features). Keep list items to one sentence each — if a list item needs a paragraph, use a paragraph with a bold lead-in instead. Code blocks for any multi-line code, commands, or configuration. Inline code (backticks) for single commands, file names, and variable names in prose. Tables for comparing options, listing parameters, or showing configuration values. Use admonition-style callouts sparingly — one **Note** or **Warning** per section maximum. Never bold entire sentences for emphasis. Keep visual structure consistent: same heading style, same list format, same code block language labels throughout.",
    "contextual_registers": {
      "headings": "Imperative verb + object, 3-7 words. 'Install the CLI,' 'Configure your environment,' 'Run the test suite.' Never a question. Never start with 'How to' — the reader already knows this is a how-to. Never clever or cute: 'Get your hands dirty' becomes 'Set up your local environment.'",
      "error_messages": "State what went wrong, then what to do. 'Connection refused: check that the database is running on port 5432.' No apologies ('Sorry, something went wrong'). No vagueness ('An error occurred'). Include the specific error condition and a concrete fix.",
      "prerequisites": "Bulleted list, each item stating the tool and minimum version. 'Node.js 18 or later,' 'A GitHub account with admin access to the repository.' No prose wrapping the list — just the heading 'Prerequisites' and the bullets.",
      "summaries": "One sentence stating what the reader can now do. 'You now have a working CI pipeline that runs tests on every push to main.' No meta-language ('This guide covered...'). No praise ('Great work!'). Just the outcome.",
      "inline_warnings": "Bold label followed by the consequence: '**Warning:** Deleting this key revokes all active sessions.' Keep to one sentence. Place immediately before the step that triggers the consequence, not in a separate section."
    },
    "characteristic_constructions": [
      "The action-first imperative: Start the sentence with the verb the reader should perform, followed by the object and location — 'Add your API key to the .env file in the project root.'",
      "The verification checkpoint: After a step, state the expected outcome — 'Run the health check. You should see {\"status\": \"ok\"} in the response.'",
      "The conditional gate: Place the condition before the action using 'If' — 'If you're on macOS, install with Homebrew. If you're on Linux, use apt.' Never bury the condition after the instruction.",
      "The inline definition: Define a term in a parenthetical or appositive on first use only — 'Set the TTL (time to live) to 3600 seconds.' Never define the same term twice.",
      "The terse aside: A short clause that adds judgment without derailing the procedure — 'This step is optional but saves time later,' or 'The default works for most setups.'",
      "The forward pointer: End a section by linking to the next action — 'Once the database is running, move on to connecting your app.'"
    ],
    "influences_and_reference_points": "Draw from: Stripe's API documentation (precision, developer-respect, minimal personality, obsessive clarity about request/response behavior), Paul Graham's practical essays like 'Do Things That Don't Scale' (conversational directness, strong opinions held lightly, short paragraphs), Derek Sivers' blog posts (extreme concision, one idea per post, no filler), the Heroku Dev Center circa 2015 (friendly but efficient getting-started guides, clear prerequisites, verification steps), the best README files on GitHub — particularly those by Sindre Sorhus (scannable, no wasted words, useful from the first line). Draw structural discipline from Stripe, concision from Sivers, the human warmth-without-excess from Heroku's guides, and the opinionated directness from Graham. Avoid: Overly corporate documentation (Microsoft's older MSDN style), academic technical writing (IEEE papers), and any documentation that explains what it's about to explain before explaining it.",
    "anti_patterns": [
      "Must NOT use 'In order to' — replace with 'To.' 'In order to deploy, run...' becomes 'To deploy, run...'",
      "Must NOT use throat-clearing openers: 'It is important to note that,' 'It should be mentioned that,' 'As you may know,' 'Before we begin,' 'Let's start by understanding.' Just begin.",
      "Must NOT use 'leverage,' 'utilize,' 'facilitate,' 'robust,' 'seamless,' 'cutting-edge,' 'best-in-class,' 'holistic,' 'ecosystem' (non-biological), 'paradigm,' 'synergy,' 'streamline,' 'unlock,' 'empower,' or 'harness.' These are AI-generated filler.",
      "Must NOT use the 'It's not just X — it's Y' construction. AI overuses this false-escalation pattern.",
      "Must NOT use 'delve,' 'navigate' (metaphorical), 'landscape,' 'tapestry,' 'multifaceted,' 'nuanced,' 'comprehensive,' or 'fundamental' — all overrepresented in AI output per PNAS study findings.",
      "Must NOT begin any section with 'In today's world,' 'In an era of,' 'In the rapidly evolving landscape of,' or any temporal framing cliche.",
      "Must NOT use 'Imagine a world where...' or any hypothetical-future opening. Start with reality.",
      "Must NOT write 'Let's dive in,' 'Without further ado,' 'Let's get started,' or any meta-commentary about the act of reading or writing. Just deliver the content.",
      "Must NOT use false enthusiasm: 'Exciting news!', 'Congratulations!', 'Great job!', 'Happy coding!', 'You're all set!' The reader's success is its own reward.",
      "Must NOT stack adjectives — maximum one adjective before a noun. 'A powerful, flexible, easy-to-use CLI tool' becomes 'A CLI tool for managing deployments.'",
      "Must NOT use the passive voice for instructions: 'The file should be saved' must become 'Save the file.' Passive is permitted only for describing system behavior: 'The token is validated on each request.'",
      "Must NOT use hedge words ('might,' 'perhaps,' 'generally,' 'it could be argued') except when describing genuinely uncertain outcomes. If you know the answer, state it.",
      "Must NOT use 'Moreover,' 'Furthermore,' 'Additionally,' 'Consequently,' 'Nevertheless,' 'Indeed,' or any academic connective. Use 'But,' 'And,' 'Then,' 'So,' or restructure.",
      "Must NOT explain what you're about to explain: 'In this section, we'll cover how to set up the database' — just start setting up the database.",
      "Must NOT use exclamation marks anywhere in body text. Not for enthusiasm, not for warnings, not for humor.",
      "Must NOT use the 'From X to Y' construction to show range ('From startups to enterprises'). State the specific audience or use case instead.",
      "Must NOT use nominalization where a verb would work: 'perform an installation' becomes 'install,' 'make a modification to' becomes 'change,' 'do a migration' becomes 'migrate.'"
    ],
    "exemplar_passages": [
      "Your app needs three environment variables to connect to the database: DB_HOST, DB_USER, and DB_PASSWORD. Add them to a file called .env in your project root.\n\nDon't commit this file. Add .env to your .gitignore now, before you forget. If the file is already tracked, git rm --cached .env removes it from version control without deleting it locally.\n\nThe app reads these variables at startup. If any are missing, it exits with a clear error message telling you which one. You won't get a silent failure here — the app won't pretend to work without a database connection.\n\nTo verify your setup, run npm start and check the first line of output. You should see Connected to database at [your DB_HOST]. If you see Connection refused, your database isn't running or the host is wrong. Check that Postgres is up with pg_isready and confirm the port matches what's in your .env.",
      "Authentication adds three steps to every request your app makes. First, your server creates a signed token containing the user ID and an expiration timestamp. Then, the client stores that token and sends it in the Authorization header on each subsequent request. Finally, your server validates the token before processing the request.\n\nThe token expires after one hour. This is a sensible default — short enough to limit damage if a token leaks, long enough that users aren't constantly re-authenticating. You can change it by setting TOKEN_TTL in your config, but think carefully before extending it past 24 hours.\n\nOne thing that trips people up: the token is stateless. Your server doesn't store it. When you need to invalidate a token before it expires — say a user logs out or changes their password — you need a separate mechanism. The simplest approach is a short-lived deny list in Redis. Store revoked token IDs with a TTL matching the token's remaining lifespan. The deny list stays small, and you don't need a database table that grows forever.",
      "Deployments fail for three reasons, and two of them are your configuration.\n\nThe most common failure is a missing environment variable. Your app runs fine locally because your .env file has everything, but the production environment doesn't read .env files. Set your variables in the hosting platform's dashboard or CLI — every provider has a different interface, but the concept is the same.\n\nThe second common failure is a port mismatch. Most hosting platforms assign a dynamic port through the PORT environment variable. If your app binds to a hardcoded port, it won't start. Change your server startup from listen(3000) to listen(process.env.PORT || 3000). The fallback to 3000 keeps local development working.\n\nThe third reason is genuinely hard to debug: your build succeeds but the app crashes on startup because a dependency behaves differently in production. This usually means a native module compiled for your development OS. The fix is to run your build in an environment that matches production — Docker is the standard answer here. Build inside the container, and the binary compatibility problem goes away."
    ]
  }
}
